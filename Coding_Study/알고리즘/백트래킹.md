## ✅ 백트래킹이 필요한 경우

1. **모든 경우의 수를 탐색해야 하는 문제**
    - 예: 완전 탐색(Brute Force)으로는 시간이 너무 오래 걸리는 경우
    - 예: 순열, 조합, 부분 집합 문제
    
2. **정답이 될 가능성이 없는 경우를 가지치기(Pruning)하여 탐색 속도를 높일 수 있는 경우**
    - 예: N-Queen 문제에서 같은 행, 열, 대각선에 놓이면 해가 될 수 없으므로 백트래킹으로 가지치기
    
3. **DFS 기반의 문제지만, 불필요한 경로 탐색을 줄여야 하는 경우**
    - 예: 특정 조건을 만족하는 경우만 탐색하는 문제 (예: 최소 횟수, 최적 해 찾기)

## 시간 복잡도
중복 허용 → $O(N^N)$ : N이 8까지 가능
중복 허용 X → $O(N!)$ : N이 10까지 가능

## 코테 예제

### N과 M

- 가능한 모든 경우 → 정답
- 트리에서 아래 갔다가 다시 위로 되돌아 오는 것. 
→ 방문 처리하고 재귀함수 호출하고 다시 방문처리 돌려놓기
→ 재귀함수는 안에 바로 종료(return) 조건 꼭 쓰기. 되도록이면 dfs 함수의 매개변수에 대해서

![[스크린샷 2025-03-07 오후 1.18.34.png]]

```python

def dfs(n,lst):
	# 종료 조건(n에 관련) 처리 + 정답 처리
	if n == M:
		ans.append(lst)
		return
	# 하부 단계(함수) 호출
	for j in range(1,N+1):
		if v[j] == 0: # 선택하지 않은 숫자인 경우
			v[j] = 1 # 방문처리
			dfs(n+1,lst+[j]) # 다음 노드의 함수
			v[j] = 0 # 방문처리 다시 되돌려 놓기

N,M = map(int,input().split())
v = [0]*(N+1)
ans = []

dfs(0,[])
for lst in ans:
	print(*lst)
```


### N-Queen
- N x N 행렬에서 놓을 수 있는 퀸이 N개이면 성공 → ans +1
- → N=4 일때, 4행으로 진행할 수 있으면 성공 
- 0행부터 확인 → 1행, 2행, ...
→ 행 안에서 Q 놓을 수 있는지(v1, v2, v3)

*아이디어*
v1: 현재 위치의 열 다 확인
v2: 오른쪽 위 대각선 : 인덱스 합 일정
v3: 오른쪽 아래 대각선 : 인덱스 차 일정
![[스크린샷 2025-03-07 오후 2.13.03.png]]

```python
def dfs(n):
	global ans
	if n == N: # N행까지 진행한 경우의 수 가능: 성공
		ans +=1
		return
	for j in range(n):
		if v1[j] == v2[n+j] == v3[n-j] == 0: # 열/대각선에 방문 가능한지 확인
			v1[j], v2[n+j], v3[n-j] = 1 # 방문 표시
			dfs(n+1)
			v1[j], v2[n+j], v3[n-j] = 0 # 방문 해제


N = int(input())
v1 = [0]*N # 열 확인 / 행은 확인할 필요 X 현재 행에 대한 함수니까.
v2 = [0]*2*N # 오른쪽 위 대각선 확인
v3 = [0]*2*N # 오른쪽 아래 대각선 확인
ans = 0

dfs(0)

```

### 부분수열의 합

N개의 정수로 이루어진 수열. 크기가 양수인 부분 수열 중, 수열의 원소를 다 더한 값이 S가 되는 경우의 수 찾기
→ DFS, 백트래킹

```python
def dfs(index, sm, cnt):
	global ans
	if index == N: ## 종료 조건
		if sm == S and cnt > 0: #  합계가 S이고 수열이 하나 이상 있으면!!
			ans+=1
		return
	## 하부 함수 호출
	dfs(n+1, sm + arr[n], cnt+1) # 포함하는 경우
	dfs(n+1, sm, cnt) # 포함하지 않는 경우



N,S = map(int, input().split())
arr = list(map(int, input().split()))
ans = 0
dfs(0,0,0)
print(ans)
```